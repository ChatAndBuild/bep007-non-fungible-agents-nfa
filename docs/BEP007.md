# BEP007 - Non-Fungible Agent (NFA) Token Standard

## Overview

The BEP007 contract is the core implementation of the Non-Fungible Agent (NFA) token standard. It extends ERC721 with specialized functionality for autonomous agents, enabling them to execute actions, manage their state, and evolve over time. This standard creates a foundation for blockchain-based AI agents that can operate with varying degrees of autonomy while maintaining owner control.

## Key Features

- **Agent Creation**: Mint new agent tokens with customizable logic and metadata
- **Action Execution**: Execute actions through agent-specific logic contracts
- **State Management**: Track and update agent state including balance and status
- **Extended Metadata**: Store rich agent metadata including persona, memory, and voice
- **Lifecycle Management**: Pause, unpause, and terminate agents
- **Memory Module Integration**: Register and interact with memory modules
- **Governance Controls**: Emergency circuit breaker and upgradability

## Contract Structure

### State Variables
- `_tokenIdCounter`: Counter for generating unique token IDs
- `governance`: Address of the governance contract
- `memoryModuleRegistry`: Address of the memory module registry
- `_agentStates`: Mapping from token ID to agent state
- `_agentMetadataURIs`: Mapping from token ID to metadata URI
- `_agentExtendedMetadata`: Mapping from token ID to extended metadata
- `globalPause`: Emergency circuit breaker flag

### Enums and Structs

#### Status Enum
```solidity
enum Status { Active, Paused, Terminated }
```

#### State Struct
```solidity
struct State {
    uint256 balance;
    Status status;
    address owner;
    address logicAddress;
    uint256 lastActionTimestamp;
}
```

#### AgentMetadata Struct
```solidity
struct AgentMetadata {
    string persona;       // JSON-encoded string for character traits, style, tone
    string memory;        // Short summary string for agent's role/purpose
    string voiceHash;     // Reference ID to stored audio profile
    string animationURI;  // URI to video or animation file
    string vaultURI;      // URI to the agent's vault (extended data storage)
    bytes32 vaultHash;    // Hash of the vault contents for verification
}
```

### Events
- `ActionExecuted`: Emitted when an agent executes an action
- `LogicUpgraded`: Emitted when an agent's logic is upgraded
- `AgentFunded`: Emitted when an agent is funded
- `StatusChanged`: Emitted when an agent's status changes
- `MetadataUpdated`: Emitted when an agent's metadata is updated
- `MemoryModuleRegistered`: Emitted when a memory module is registered

### Functions

#### Initialization
```solidity
function initialize(
    string memory name, 
    string memory symbol,
    address governanceAddress
) public initializer
```
Initializes the contract with a name, symbol, and governance address.

#### Agent Creation
```solidity
function createAgent(
    address to, 
    address logicAddress, 
    string memory metadataURI,
    AgentMetadata memory extendedMetadata
) external returns (uint256 tokenId)
```
Creates a new agent token with extended metadata.

```solidity
function createAgent(
    address to, 
    address logicAddress, 
    string memory metadataURI
) external returns (uint256 tokenId)
```
Creates a new agent token with basic metadata.

#### Action Execution
```solidity
function executeAction(
    uint256 tokenId, 
    bytes calldata data
) external nonReentrant whenAgentActive(tokenId)
```
Executes an action using the agent's logic.

#### Logic Management
```solidity
function setLogicAddress(
    uint256 tokenId, 
    address newLogic
) external onlyAgentOwner(tokenId)
```
Updates the logic address for the agent.

#### Funding
```solidity
function fundAgent(uint256 tokenId) external payable
```
Funds the agent with BNB for gas fees.

#### State and Metadata
```solidity
function getState(uint256 tokenId) external view returns (State memory)
```
Returns the current state of the agent.

```solidity
function getAgentMetadata(uint256 tokenId) external view returns (AgentMetadata memory)
```
Gets the agent's extended metadata.

```solidity
function updateAgentMetadata(
    uint256 tokenId, 
    AgentMetadata memory metadata
) external onlyAgentOwner(tokenId)
```
Updates the agent's extended metadata.

```solidity
function setAgentMetadataURI(
    uint256 tokenId, 
    string memory newMetadataURI
) external onlyAgentOwner(tokenId)
```
Updates the agent's metadata URI.

#### Memory Module Integration
```solidity
function registerMemoryModule(
    uint256 tokenId, 
    address moduleAddress
) external onlyAgentOwner(tokenId)
```
Registers a memory module for the agent.

#### Lifecycle Management
```solidity
function pause(uint256 tokenId) external onlyAgentOwner(tokenId)
```
Pauses the agent.

```solidity
function unpause(uint256 tokenId) external onlyAgentOwner(tokenId)
```
Resumes the agent.

```solidity
function terminate(uint256 tokenId) external onlyAgentOwner(tokenId)
```
Terminates the agent permanently.

#### Governance Controls
```solidity
function setGlobalPause(bool paused) external onlyGovernance
```
Sets the global pause state (emergency circuit breaker).

```solidity
function setGovernance(address newGovernance) external onlyGovernance
```
Updates the governance address.

```solidity
function setMemoryModuleRegistry(address registry) external onlyGovernance
```
Sets the memory module registry address.

#### Fund Management
```solidity
function withdrawFromAgent(
    uint256 tokenId, 
    uint256 amount
) external onlyAgentOwner(tokenId)
```
Withdraws BNB from the agent.

## Security Considerations
- Reentrancy protection for all fund transfers
- Gas limit for delegatecall to prevent out-of-gas attacks
- Owner-only access for critical functions
- Governance-controlled emergency circuit breaker
- Balance tracking to prevent overdrafts

## Integration Points
- Interacts with agent logic contracts via delegatecall
- Connects to memory module registry for extended functionality
- Controlled by BEP007Governance for protocol-level decisions
- Supports ERC721 standard for NFT marketplace compatibility

## Use Cases
1. **Autonomous DeFi Agents**: Create agents that can execute trades, provide liquidity, or manage yield farming strategies
2. **Creator Agents**: Deploy agents that can create, curate, and distribute content on behalf of creators
3. **Gaming Agents**: Implement in-game characters with autonomous behaviors and persistent state
4. **DAO Representatives**: Create official representatives for DAOs that can communicate and execute governance decisions
5. **Personal Assistants**: Deploy agents that can perform tasks and manage digital assets on behalf of users
